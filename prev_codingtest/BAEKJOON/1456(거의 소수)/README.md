# 백준 1456_거의소수

## [거의소수](https://www.acmicpc.net/problem/1456)

## 문제 해석
- 소수의 N(N>=2) 제곱꼴을 **거의 소수**라고 정의
- 입력값: 정수 A, B(1 <= A <= B <= 10^14)
- 출력값: A보다 크거나 같고, B보다 작거나 같은 **거의 소수**의 개수

## 문제 풀이1
- 최대값이 100조가 넘으면서 일반적인 탐색이 아닌 이분탐색으로 해야한다.(또는 로그값을 취하거나, sqrt 등)
- A, B사이의 소수는 [에라토스테네스의 체](https://velog.io/@cjy0029/%EC%86%8C%EC%88%98-%EA%B5%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95)를 이용해서 구한다.
  - 2부터 순회하면서 2의 배수를 없애고, 
  - 1씩 증가시키면서 배수들을 전부 없애준다.
  - 주어진 수의 제곱근 이하까지
- A가 1 또는 2인경우 에라토스테네스의 체를 바로 적용
- 그렇지 않은 경우 A 초과의 값에서 나오는 소수 부터 적용

## 문제풀이1 → 내 방법은 복잡도로 절때 불가능하다고 판단
- [블로그](https://velog.io/@lixxce/lfi9y7k8) 참고..(무기력해진다.)
- 에라토스테네스의 체 이용
> 위에서 사용하려고했던 방법이 맞다.. 복잡하게 생각할 필요가 없었다.. 그냥 위에 방법대로 밀고 나갔으면 나왔을 것이다..
1. remove 방식으로 제거하는 것이 아닌 true, false 소수 값을 미리 계산해 둔다.
   - 제곱근까지만 보면 되기 때문에 최대값은 10^7
   - 반복문을 전부 돌면서 i의 배수인지 확인하는건(stupid) 반복문을 돌 때, i의 배수만큼 더해가면서 돌면된다.
   - 처음 시작값도 i * i 부터 돌게해서 i는 포함안되도록 돌기
2. 1번에서 2 ~ 10^7까지의 모든 소수가 나왔다.
    - true로 설정된 인덱스가 소수이며, 해당 소수를 배수들이 A 이상 B 이하에 포함되는지 반복하면서 개수 카운트
    - 증가되는 i는 i의 배수인거 확인 필수
- `당연히 터질줄 알았는데 그냥 쉽게 접근하면되는거였다...`

## 자료 구조&복잡도(블로그)
- N * log(N) + N * log(N)
- O(Nlog(N))?..

## 중요점
**- 소수를 구하는 방법: 에라토스테네스의 체**
**- 소수는 최대값의 제곱근까지만 확인해도 된다!**
