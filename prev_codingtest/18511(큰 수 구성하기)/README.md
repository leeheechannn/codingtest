# 백준_18511 큰 수 구성하기

## [백준 18511](https://www.acmicpc.net/problem/18511) 난이도: 실버 5

## 문제해석
- N 보다 작거나 같은 자연수 중에서, 집합 K 원소로만 구성된 가장 큰 수
- ex) N = 657, K = {1, 5, 7}인 경우 답은 "577"
- 입력: N와 K의 원소 개수(10 <= 100,000,000, 1<= K의 원소 개수 <= 3)
  - K의 모든 원소는 1~9(0 제외)
  - 둘 째 줄에 K의 원소 개수 만큼 자연수 입력
- 출력: N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수

## 문제 풀이
- 0은 없으니 구성 불가능한 케이스는 없다.
- 먼저, K원소 정렬
- N의 젤 높은 숫자 도출, K 원소 중 젤 높은 숫자보다 작은 값 지정
- 나머지 N 숫자들을 K 원소 중 가장 높은 수로 배정
- 젤 높은 숫자에서 내려갈 수록 K 원소 중 젤 높은수와 같은 경우 예외처리 해줘야한다.

## 첫번째 코드로 실패 후..(commit) 반례를 찾아보던 중 큰 실수 발견
- 반례를 스스로 만들어 낼 수 있어야하는데ㅠㅠ
- 모든 자리수가 K 원소보다 작다는 보장은 없다. 
- 주어진 N 보다 작은 즉, 한자리수가 작게 구성할 수 있다.
- 또 다른 반례로 경우싀 수 발생
- 위에처럼 자리수가 작은 경우는.. 거기서 멈추고 뒤에값들을 전부 최대값으로 하는게아니고..
- 그냥 처음부터 최대값으로 채우는게 무조건 큰값이다...어휴
- 다시 또 다른 반례에서..이런 실수를 한다. 왜이렇게 생각이라는걸 안하고 살려고하는걸까?..
- 무조건 자리수가 작은게 큰게 아니네..진짜 바보인가..반례가 나왔다고 그냥 그래 수긍이아니라 한번쯤은 생각하자...
- 예) 510 {1, 5, 7} → 177이 77보다 큼

## 문제풀이2
- 문제풀이 1과 동일한 방식으로 진행하지만, DFS 방식 추가(모든 경우의 수 처리하기위함)
- N의 각 자리랑 비교 해서 같은 경우에는 스택에 넣기
- 이후 N의 특정 자리 수 가 K의 모든 원소보다 작은 경우는 두 가지 경우다.
  - (일반적으로 앞에 있는 수 들이 전부 다 K의 원소랑 같은 경우에 발생함)
  1. 같은 자리수로는 만들지 못해 결국 N보다 한 자리 낮은 수로 구성하거나
  2. 더 큰 자리수에서 K 원소에 작은 값이 있는 경우
- 1번의 경우 자리 수 낮춰서 큰 수로 전체 구성
- 2번의 경우 작은 값을 발견한 이후부터 큰 수로 구성

## 자료구조 및 복잡도
- 복잡도 O(N)

## 다른사람들 풀이
- 받아온 리스트를 가지고 구성할 수 있는 모든 경우의 수를 다 계산하고
- 계산한 값이 N보다 작은 값 중에서 최대값을 가지는 경우로
- 출력한다.
- product와 같이 조합으로 계산하는것도 가능.. 가능한 수가 모두 나오니깐
```python
n, k = map(int, input().split())
s = set(input().split())

def dfs(current, result):
    if current == 0:
        if int(result) <= n:
            print(result)
            exit()
        return

    for i in reversed(sorted(s)):
      #큰 값부터 넣어가면서 str 길이만큼 계속해서 반복해서 데이터 계산
      #큰 값 부터 넣었기 때문에 n보다 작거나 같으면 가장 큰 값으로 출력
        result += i
        dfs(current - 1, result)
        result = result[:-1]

dfs(len(str(n)), "")
#위에 dfs에서 종료되지 않는다면 자리 수 줄여서 최대값 다시 탐색
dfs(len(str(n)) - 1, "")
```